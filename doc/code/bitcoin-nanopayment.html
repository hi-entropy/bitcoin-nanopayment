<!DOCTYPE html>

<html>
<head>
  <title>bitcoin-nanopayment.js</title>
  <meta http-equiv="content-type" content="text/html; charset=UTF-8">
  <meta name="viewport" content="width=device-width, target-densitydpi=160dpi, initial-scale=1.0; maximum-scale=1.0; user-scalable=0;">
  <link rel="stylesheet" media="all" href="docco.css" />
</head>
<body>
  <div id="container">
    <div id="background"></div>
    
      <ul id="jump_to">
        <li>
          <a class="large" href="javascript:void(0);">Jump To &hellip;</a>
          <a class="small" href="javascript:void(0);">+</a>
          <div id="jump_wrapper">
          <div id="jump_page">
            
              
              <a class="source" href="base58.html">
                base58.js
              </a>
            
              
              <a class="source" href="bitcoin-nanopayment.html">
                bitcoin-nanopayment.js
              </a>
            
              
              <a class="source" href="demo.html">
                demo.js
              </a>
            
              
              <a class="source" href="jsbn-patched.html">
                jsbn-patched.js
              </a>
            
              
              <a class="source" href="script.html">
                script.js
              </a>
            
              
              <a class="source" href="test-base58.html">
                test-base58.js
              </a>
            
              
              <a class="source" href="test-jsbn.html">
                test-jsbn.js
              </a>
            
              
              <a class="source" href="test-payment.html">
                test-payment.js
              </a>
            
              
              <a class="source" href="test-random.html">
                test-random.js
              </a>
            
              
              <a class="source" href="util.html">
                util.js
              </a>
            
          </div>
        </li>
      </ul>
    
    <ul class="sections">
        
          <li id="title">
              <div class="annotation">
                  <h1>bitcoin-nanopayment.js</h1>
              </div>
          </li>
        
        
        
        <li id="section-1">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1">&#182;</a>
              </div>
              <p>Copyright 2013 Paul Kernfeld</p>
<p>This file is part of bitcoin-nanopayment.</p>
<p> bitcoin-nanopayment is free software: you can redistribute it and/or modify
 it under the terms of the GNU General Public License as published by
 the Free Software Foundation, either version 3 of the License, or
 (at your option) any later version.</p>
<p> bitcoin-nanopayment is distributed in the hope that it will be useful,
 but WITHOUT ANY WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 GNU General Public License for more details.</p>
<p> You should have received a copy of the GNU General Public License
 along with bitcoin-nanopayment.  If not, see <a href="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</a>.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre><span class="string">'use strict'</span>;</pre></div></div>
            
        </li>
        
        
        <li id="section-2">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-2">&#182;</a>
              </div>
              <p>Internal imports</p>

            </div>
            
            <div class="content"><div class='highlight'><pre><span class="keyword">var</span> BigInteger = require(<span class="string">'./jsbn-patched'</span>).BigInteger;
<span class="keyword">var</span> base58 = require(<span class="string">'./base58'</span>);
<span class="keyword">var</span> script = require(<span class="string">'./script'</span>);
<span class="keyword">var</span> util = require(<span class="string">'./util'</span>);</pre></div></div>
            
        </li>
        
        
        <li id="section-3">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-3">&#182;</a>
              </div>
              <p>External imports</p>

            </div>
            
            <div class="content"><div class='highlight'><pre><span class="keyword">var</span> bitcoin = require(<span class="string">'bitcoin'</span>);
<span class="keyword">var</span> async = require(<span class="string">'async'</span>);
<span class="keyword">var</span> assert = require(<span class="string">'assert'</span>);</pre></div></div>
            
        </li>
        
        
        <li id="section-4">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-4">&#182;</a>
              </div>
              <p>Satoshis per Bitcoin.  All math is done in Satoshis to avoid rounding errors.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre><span class="keyword">var</span> SATOSHIS = <span class="number">100000000.</span>;</pre></div></div>
            
        </li>
        
        
        <li id="section-5">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-5">&#182;</a>
              </div>
              <p>Hard-code the amount to pay for now (0.01 Bitcoins)</p>

            </div>
            
            <div class="content"><div class='highlight'><pre><span class="keyword">var</span> AMOUNT = <span class="number">1000000</span>;</pre></div></div>
            
        </li>
        
        
        <li id="section-6">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-6">&#182;</a>
              </div>
              <p>10 seconds should be plenty of time to round-trip a voucher request</p>

            </div>
            
            <div class="content"><div class='highlight'><pre><span class="keyword">var</span> DEFAULT_TIMEOUT = <span class="number">10000</span>;</pre></div></div>
            
        </li>
        
        
        <li id="section-7">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-7">&#182;</a>
              </div>
              <p>The version byte for testnet public addresses</p>

            </div>
            
            <div class="content"><div class='highlight'><pre><span class="keyword">var</span> TESTNET_PUBLIC_VERSION = <span class="number">111</span>;</pre></div></div>
            
        </li>
        
        
        <li id="section-8">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-8">&#182;</a>
              </div>
              <p>How many possible txid&#39;s are there?  32 bytes = 16 ^ 64</p>

            </div>
            
            <div class="content"><div class='highlight'><pre><span class="keyword">var</span> TXID_RANGE_BI = <span class="keyword">new</span> BigInteger();
TXID_RANGE_BI.fromString(<span class="string">'10000000000000000000000000000000000000000000000000000000000000000'</span>, <span class="number">16</span>);</pre></div></div>
            
        </li>
        
        
        <li id="section-9">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-9">&#182;</a>
              </div>
              <p>Turn the target into a serialized, URL-safe string</p>
<p>TODO: this should just take a JSON object, jeez</p>

            </div>
            
            <div class="content"><div class='highlight'><pre><span class="keyword">var</span> serializeTarget = exports.serializeTarget =
  <span class="keyword">function</span>(amount, length, vout, start) {
    <span class="keyword">return</span> amount + <span class="string">'-'</span> + length + <span class="string">'-'</span> + vout + <span class="string">'-'</span> + start;
  };</pre></div></div>
            
        </li>
        
        
        <li id="section-10">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-10">&#182;</a>
              </div>
              <p>Convert this serialized target into a JS object representing the target</p>

            </div>
            
            <div class="content"><div class='highlight'><pre><span class="keyword">var</span> deserializeTarget = exports.deserializeTarget = <span class="keyword">function</span>(target) {
  assert(<span class="keyword">typeof</span> target === <span class="string">'string'</span>, <span class="string">'target must be a string'</span>);

  <span class="keyword">var</span> split = target.split(<span class="string">'-'</span>);
  assert(
    split.length === <span class="number">4</span>,
    <span class="string">'target has '</span> + split.length + <span class="string">' values, should have 4'</span>
  );
  <span class="keyword">return</span> {
    amount: parseInt(split[<span class="number">0</span>]),
    length: parseInt(split[<span class="number">1</span>]),
    vout: parseInt(split[<span class="number">2</span>]),
    start: split[<span class="number">3</span>]
  };
};

exports.Client = <span class="keyword">function</span>(clientConfig) {

  <span class="keyword">var</span> rpcConfig = clientConfig.rpc;
  assert(rpcConfig, <span class="string">'The rpcConfig must exist'</span>);</pre></div></div>
            
        </li>
        
        
        <li id="section-11">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-11">&#182;</a>
              </div>
              <p>This object encapsulates logic to request, send, and cash in vouchers.
Currently, it uses only one Bitcoin address.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  <span class="keyword">this</span>.Account = <span class="keyword">function</span>(address, privateKey) {</pre></div></div>
            
        </li>
        
        
        <li id="section-12">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-12">&#182;</a>
              </div>
              <p>Set default values</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="keyword">var</span> timeout = clientConfig.timeout;
    <span class="keyword">var</span> minConf = clientConfig.minConf;
    timeout = <span class="keyword">typeof</span> timeout === <span class="string">'undefined'</span> ? DEFAULT_TIMEOUT : timeout;
    minConf = <span class="keyword">typeof</span> minConf === <span class="string">'undefined'</span> ? <span class="number">1</span> : minConf;</pre></div></div>
            
        </li>
        
        
        <li id="section-13">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-13">&#182;</a>
              </div>
              <p>Verify argument types</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    assert(util.isAddress(address), <span class="string">'address must be a valid Bitcoin address'</span>);
    assert(
      util.isPrivateKey(privateKey),
      <span class="string">'privatekey must be a valid private key'</span>
    );
    assert(<span class="keyword">typeof</span> timeout == <span class="string">'number'</span>, <span class="string">'timeout must be a number'</span>);
    assert(util.isInt(minConf), <span class="string">'minConf must be an integer'</span>);</pre></div></div>
            
        </li>
        
        
        <li id="section-14">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-14">&#182;</a>
              </div>
              <p>Convert the address into hex representation</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="keyword">var</span> addressBinary = base58.decodeChecked(address);
    assert.equal(addressBinary.version, TESTNET_PUBLIC_VERSION);
    <span class="keyword">var</span> addressHex = addressBinary.payload.toString(<span class="string">'hex'</span>);

    <span class="keyword">var</span> client = <span class="keyword">new</span> bitcoin.Client(rpcConfig);</pre></div></div>
            
        </li>
        
        
        <li id="section-15">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-15">&#182;</a>
              </div>
              <p>The target allows us to validate and cash incoming vouchers.  It contains
information about the range of txid&#39;s that may be guessed, and the hex
transaction we&#39;ll submit if we cash an incoming voucher.</p>
<p>{
  start: BigInteger,
  length: integer,
  offset: integer,
  transactionHex: hex string
}</p>
<p>If this is null, no incoming voucher is valid</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="keyword">var</span> currentTarget = <span class="literal">null</span>;</pre></div></div>
            
        </li>
        
        
        <li id="section-16">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-16">&#182;</a>
              </div>
              <p>This queue is basically just a lock, so it&#39;s always called with a
concurrency of 1.  The purpose is to prevent us from doing two operations
at the same time, e.g. double spending.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="keyword">var</span> queue;
    queue = async.queue(
      <span class="function"><span class="keyword">function</span> <span class="params">(task, cb)</span> {</span> task(cb); },
      <span class="number">1</span>
    );</pre></div></div>
            
        </li>
        
        
        <li id="section-17">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-17">&#182;</a>
              </div>
              <p>This must be finished running before using this account can be used.
This function initializes the account by looking up the previous unspent
transactions into this address.  These are necessary because we&#39;re creating
raw transactions, for which we need txid&#39;s
of previous transactions.</p>
<p>TODO: verify that the private key matches the public key</p>
<p>When this finishes, it calls cb(err, previous).  previous is:
{
  balance: [int, in Satoshis],
  txid: [hex string],
  vout: [integer]<br>}</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="keyword">var</span> getPrevious = <span class="keyword">function</span>(cb) {
      <span class="keyword">var</span> balance = <span class="literal">null</span>;
      <span class="keyword">var</span> previousTxid;
      <span class="keyword">var</span> previousVout;</pre></div></div>
            
        </li>
        
        
        <li id="section-18">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-18">&#182;</a>
              </div>
              <p>Retrieve the txid of the most recent tx into my account</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      client.cmd(
        <span class="string">'listunspent'</span>,
        minConf,
        <span class="number">999999</span>,
        [address],
        <span class="keyword">function</span>(err, transactions) {
          <span class="keyword">if</span>(err) {
            cb(err);
            <span class="keyword">return</span>;
          }</pre></div></div>
            
        </li>
        
        
        <li id="section-19">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-19">&#182;</a>
              </div>
              <p>Select the largest unspent output.</p>
<p>TODO: Add the ability to combine multiple outputs.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          <span class="keyword">for</span> (<span class="keyword">var</span> i <span class="keyword">in</span> transactions) {
            <span class="keyword">var</span> transactionAmount =
              Math.round(transactions[i].amount * SATOSHIS);
            <span class="keyword">if</span> (balance === <span class="literal">null</span> ||
                transactionAmount &gt; balance) {
              previousTxid = transactions[i].txid;
              previousVout = transactions[i].vout;
              balance = transactionAmount;
            }
          }
          
          <span class="keyword">if</span>(balance &lt; AMOUNT) {
            cb(<span class="string">"You don't have enoungh Bitcoins.  You need at least "</span> + AMOUNT +
               <span class="string">' Satoshis to use this, you only have '</span> + balance);
          } <span class="keyword">else</span> <span class="keyword">if</span> (balance === <span class="literal">null</span>) {
            cb(
              <span class="string">'No unspent transactions found.  '</span> +
                <span class="string">'Maybe there is an unconfirmed transaction to this address?'</span>);
          } <span class="keyword">else</span> {
            cb(<span class="literal">null</span>, {
              balance: balance,
              txid: previousTxid,
              vout: previousVout
            });
          }
        }
      );
    };</pre></div></div>
            
        </li>
        
        
        <li id="section-20">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-20">&#182;</a>
              </div>
              <p>Produce a voucher request which specifies the range of acceptable txid&#39;s
to pay to.</p>
<ul>
<li>inverseProbability - int, the probability of the voucher being cashable,
  to the -1 power</li>
<li>fromAddress - the Base58-encoded address from which to request voucher</li>
</ul>
<p>After calling this, we wait for a period of time before doing any more
voucher operations because doing other operations may invalidate the
target.  After the period of time has expired, we unlock the queue so that
we can continue processing other operations.</p>
<p>On failure, call cb(error)</p>
<p>On success, call cb(null, target) where target is a serialized target</p>
<p>The serialized target can be sent to the payer.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="keyword">this</span>.requestVoucher = <span class="keyword">function</span>(inverseProbability, fromAddress, cb) {

      assert(
        util.isInt(inverseProbability),
        <span class="string">'inverseProbability must be an integer'</span>
      );
      assert(inverseProbability &gt;= <span class="number">1</span>, <span class="string">'inverseProbability must be &gt;= 1'</span>);
      assert(util.isAddress(fromAddress), <span class="string">'fromAddress must be a string'</span>);</pre></div></div>
            
        </li>
        
        
        <li id="section-21">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-21">&#182;</a>
              </div>
              <p>This is a separate fn so that we can push it onto the queue</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="keyword">var</span> requestVoucher = <span class="keyword">function</span>(queueCb) {

        async.waterfall([</pre></div></div>
            
        </li>
        
        
        <li id="section-22">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-22">&#182;</a>
              </div>
              <p>Get the previous transaction info</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          getPrevious,</pre></div></div>
            
        </li>
        
        
        <li id="section-23">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-23">&#182;</a>
              </div>
              <p>Create the transaction</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          <span class="keyword">function</span>(previous, waterfallCb) {</pre></div></div>
            
        </li>
        
        
        <li id="section-24">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-24">&#182;</a>
              </div>
              <p>We pay the amount for the transaction to the counterparty and send
the change to ourselves. This is backwards, yes, but we need this
to generate our secret txid. Don&#39;t worry, we&#39;re not actually
submitting this to the Bitcoin network yet.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>            <span class="keyword">var</span> outputs = {};
            outputs[fromAddress] = AMOUNT / SATOSHIS;</pre></div></div>
            
        </li>
        
        
        <li id="section-25">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-25">&#182;</a>
              </div>
              <p>We need to send change to ourself iff there&#39;s money left over</p>
<p>TODO: pull this functionality out</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>            <span class="keyword">if</span> (previous.balance &gt; AMOUNT) {
              outputs[address] = (previous.balance - AMOUNT) / SATOSHIS;
              assert.equal(
                Math.round((outputs[fromAddress] + outputs[address]) * SATOSHIS),
                previous.balance,
                <span class="string">'Balance rounding error!?'</span>
              );
            }

            client.cmd(
              <span class="string">'createrawtransaction'</span>,
              [{<span class="string">'txid'</span>: previous.txid, <span class="string">'vout'</span>: previous.vout}],
              outputs,
              waterfallCb
            );
          },</pre></div></div>
            
        </li>
        
        
        <li id="section-26">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-26">&#182;</a>
              </div>
              <p>Sign the transaction</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          <span class="keyword">function</span>(transactionHex, waterfallCb) {
            client.cmd(<span class="string">'signrawtransaction'</span>, transactionHex, waterfallCb);
          },</pre></div></div>
            
        </li>
        
        
        <li id="section-27">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-27">&#182;</a>
              </div>
              <p>Decode the signed transaction</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          <span class="keyword">function</span>(signed, waterfallCb) {</pre></div></div>
            
        </li>
        
        
        <li id="section-28">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-28">&#182;</a>
              </div>
              <p>Make sure Bitcoin-QT signed the transaction properly.</p>
<p>TODO: would this ever fail?</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>            <span class="keyword">if</span> (!signed.complete) {
              waterfallCb(<span class="string">'Setup transaction not complete'</span>);
              <span class="keyword">return</span>;
            }

            client.cmd(
              <span class="string">'decoderawtransaction'</span>,
              signed.hex,
              <span class="keyword">function</span>(err, transactionJson) {
                waterfallCb(err, signed, transactionJson);
              }
            );
          },</pre></div></div>
            
        </li>
        
        
        <li id="section-29">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-29">&#182;</a>
              </div>
              <p>Store the decoded transaction</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          <span class="keyword">function</span>(signed, transactionJson, waterfallCb) {</pre></div></div>
            
        </li>
        
        
        <li id="section-30">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-30">&#182;</a>
              </div>
              <p>This is just a sanity check specific to this implementation</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>            assert(
              transactionJson.vout.length == <span class="number">1</span> ||
                transactionJson.vout.length == <span class="number">2</span>,
              <span class="string">'Unexpected number of vouts'</span>
            );

            <span class="keyword">var</span> txid = transactionJson.txid;</pre></div></div>
            
        </li>
        
        
        <li id="section-31">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-31">&#182;</a>
              </div>
              <p>The start of the target range is the txid minus a random offset</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>            <span class="keyword">var</span> offset = util.cryptoRandom(inverseProbability);
            <span class="keyword">var</span> offsetBi = <span class="keyword">new</span> BigInteger();
            offsetBi.fromInt(offset);
            <span class="keyword">var</span> startBi = <span class="keyword">new</span> BigInteger();
            startBi.fromString(txid, <span class="number">16</span>);
            startBi = startBi.subtract(offsetBi).mod(TXID_RANGE_BI);</pre></div></div>
            
        </li>
        
        
        <li id="section-32">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-32">&#182;</a>
              </div>
              <p>Store the target as a JSON object.  We OVERWRITE the previous
target -- it&#39;s now invalid.  Why?  If we received a cashable
voucher for each target, we couldn&#39;t cash both.  So, we can only
have one target open at a time.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>            currentTarget = {
              start: startBi,
              length: inverseProbability,
              offset: offset,
              transactionHex: signed.hex
            };</pre></div></div>
            
        </li>
        
        
        <li id="section-33">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-33">&#182;</a>
              </div>
              <p>Success</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>            <span class="keyword">var</span> target = serializeTarget(
              AMOUNT,
              currentTarget.length,
              <span class="number">0</span>,
              startBi.toString(<span class="number">16</span>)
            );
            waterfallCb(<span class="literal">null</span>, target);</pre></div></div>
            
        </li>
        
        
        <li id="section-34">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-34">&#182;</a>
              </div>
              <p>Wait for a little before we free up the queue.  This gives use a
time window to get paid before we being our next operation.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>            setTimeout(queueCb, timeout);
          }
        ], cb);
      };</pre></div></div>
            
        </li>
        
        
        <li id="section-35">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-35">&#182;</a>
              </div>
              <p>The function that gets run when this gets popped off the queue is
actually a no-op.  We manually call cb from inside the queued function,
so it&#39;s fine.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      queue.push(requestVoucher, <span class="keyword">function</span>() {});
    };</pre></div></div>
            
        </li>
        
        
        <li id="section-36">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-36">&#182;</a>
              </div>
              <p>Create a voucher.</p>
<ul>
<li>destinationAddress: the Base58-encoded address to which to pay the money</li>
<li>target, a serialized target</li>
</ul>
<p>On failure, we call cb(error)
On success, we call cb(null, transactionHex)</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="keyword">this</span>.createVoucher = <span class="keyword">function</span>(destinationAddress, targetSerialized, cb) {</pre></div></div>
            
        </li>
        
        
        <li id="section-37">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-37">&#182;</a>
              </div>
              <p>Check the inputs</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      assert(util.isAddress(destinationAddress));</pre></div></div>
            
        </li>
        
        
        <li id="section-38">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-38">&#182;</a>
              </div>
              <p>Decode the target.  If we get an error, the target is invalid.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="keyword">var</span> target;
      <span class="keyword">try</span> {
        target = deserializeTarget(targetSerialized);
      } <span class="keyword">catch</span> (err) {
        cb(<span class="string">'Error deserializing target: '</span> + err);
        <span class="keyword">return</span>;
      }</pre></div></div>
            
        </li>
        
        
        <li id="section-39">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-39">&#182;</a>
              </div>
              <p>We only create vouchers for exactly AMOUNT Satoshis</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="keyword">if</span> (target.amount != AMOUNT) {
        cb(<span class="string">'Transaction amount was '</span> + target.amount + <span class="string">', must be '</span> + AMOUNT);
        <span class="keyword">return</span>;
      }</pre></div></div>
            
        </li>
        
        
        <li id="section-40">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-40">&#182;</a>
              </div>
              <p>We can&#39;t pay ourselves using this method</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="keyword">if</span>(destinationAddress == address) {
        cb(
          <span class="string">'The paying address may not be the same as the destination address'</span>);
        <span class="keyword">return</span>;
      }</pre></div></div>
            
        </li>
        
        
        <li id="section-41">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-41">&#182;</a>
              </div>
              <p>This is a separate fn so we can push it onto the queue</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="keyword">var</span> createVoucher = <span class="keyword">function</span>(queueCb) {

        async.waterfall([</pre></div></div>
            
        </li>
        
        
        <li id="section-42">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-42">&#182;</a>
              </div>
              <p>Get my previous tx info and balance</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          getPrevious,</pre></div></div>
            
        </li>
        
        
        <li id="section-43">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-43">&#182;</a>
              </div>
              <p>Ask the client to create this transaction.  This doesn&#39;t actually send anything, it just
creates a binary string representing the transaction.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          <span class="keyword">function</span>(previous, waterfallCb) {</pre></div></div>
            
        </li>
        
        
        <li id="section-44">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-44">&#182;</a>
              </div>
              <p>Make sure we have enough money</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>            <span class="keyword">if</span>(AMOUNT &gt; previous.balance) {
              cb(<span class="string">'Need '</span> + AMOUNT + <span class="string">', only have '</span> + previous.balance);
              <span class="keyword">return</span>;
            }</pre></div></div>
            
        </li>
        
        
        <li id="section-45">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-45">&#182;</a>
              </div>
              <p>Our payment to the destination is the actual voucher.  We must also return the money paid
in the original transaction back to the payee.  So, we pay double the amount to the
destination address</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>            <span class="keyword">var</span> outputs = {};
            outputs[destinationAddress] = AMOUNT * <span class="number">2</span> / SATOSHIS;</pre></div></div>
            
        </li>
        
        
        <li id="section-46">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-46">&#182;</a>
              </div>
              <p>We need to send change to ourself iff there&#39;s money left over</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>            <span class="keyword">if</span> (AMOUNT &lt; previous.balance) {
              outputs[address] = (previous.balance - AMOUNT) / SATOSHIS;
              assert.equal(Math.round((outputs[destinationAddress] + outputs[address]) * SATOSHIS), previous.balance + AMOUNT);
            }</pre></div></div>
            
        </li>
        
        
        <li id="section-47">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-47">&#182;</a>
              </div>
              <p>Randomly guess a number in the target range</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>            <span class="keyword">var</span> targetStartBi = <span class="keyword">new</span> BigInteger();
            targetStartBi.fromString(target.start, <span class="number">16</span>);
            <span class="keyword">var</span> randomBi = <span class="keyword">new</span> BigInteger();
            randomBi.fromInt(util.cryptoRandom(target.length));
            <span class="keyword">var</span> previousTxidGuess = targetStartBi.add(randomBi).mod(TXID_RANGE_BI).toString(<span class="number">16</span>);</pre></div></div>
            
        </li>
        
        
        <li id="section-48">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-48">&#182;</a>
              </div>
              <p>Pad the guessed transaction ID with zeros</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>            <span class="keyword">while</span>(previousTxidGuess.length &lt; <span class="number">64</span>) {
              previousTxidGuess = <span class="string">'0'</span> + previousTxidGuess;
            }

            <span class="keyword">var</span> waterfallTranslator = <span class="keyword">function</span>(err, transactionHex) {
              waterfallCb(err, transactionHex, previousTxidGuess);
            }

            client.cmd(<span class="string">'createrawtransaction'</span>, [{<span class="string">'txid'</span>: previousTxidGuess, <span class="string">'vout'</span>: target.vout}, {<span class="string">'txid'</span>: previous.txid, <span class="string">'vout'</span>: previous.vout}], outputs, waterfallTranslator);
          },</pre></div></div>
            
        </li>
        
        
        <li id="section-49">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-49">&#182;</a>
              </div>
              <p>The transaction was successfully created.  Now sign it.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          <span class="keyword">function</span>(transactionHex, previousTxidGuess, waterfallCb) {
            <span class="keyword">var</span> scriptPubKey = script.addressToScript(addressHex);

            client.cmd(<span class="string">'signrawtransaction'</span>, transactionHex, [{<span class="string">'txid'</span>: previousTxidGuess,<span class="string">'vout'</span>: target.vout, <span class="string">'scriptPubKey'</span>: scriptPubKey, <span class="string">'redeemScript'</span>: privateKey}], waterfallCb);
          },</pre></div></div>
            
        </li>
        
        
        <li id="section-50">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-50">&#182;</a>
              </div>
              <p>We signed the transaction, now invalidate the current target</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          <span class="keyword">function</span>(signed, waterfallCb) {</pre></div></div>
            
        </li>
        
        
        <li id="section-51">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-51">&#182;</a>
              </div>
              <p>I think that this means that the transaction is potentially valid. TODO: verify</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>            assert(signed.complete);</pre></div></div>
            
        </li>
        
        
        <li id="section-52">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-52">&#182;</a>
              </div>
              <p>Since we may send this voucher out and it&#39;s using the same prevout
as the current  target, we must declare the current target
invalid.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>            currentTarget = <span class="literal">null</span>;
            
            waterfallCb(<span class="literal">null</span>, signed.hex);
          }
        ], queueCb);
      };

      queue.push(createVoucher, cb);
    };</pre></div></div>
            
        </li>
        
        
        <li id="section-53">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-53">&#182;</a>
              </div>
              <p>Cash in a voucher.</p>
<ul>
<li>transactionHex: a voucher payable to me</li>
</ul>
<p>This doesn&#39;t need to be synchronized using the queue.</p>
<p>If the voucher is invalid, call cb(err)
If the voucher is valid, call cb(null, cashed)</p>
<p>cashed is a boolean indicating whether this transaction was cashed</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="keyword">this</span>.cashVoucher = <span class="keyword">function</span>(transactionHex, cb) {</pre></div></div>
            
        </li>
        
        
        <li id="section-54">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-54">&#182;</a>
              </div>
              <p>verify the txid</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      client.cmd(<span class="string">'decoderawtransaction'</span>, transactionHex, <span class="keyword">function</span>(err, transactionJson) {

        <span class="keyword">if</span>(err) {
          cb(<span class="string">'Error decoding transaction: '</span> + err);
          <span class="keyword">return</span>;
        }</pre></div></div>
            
        </li>
        
        
        <li id="section-55">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-55">&#182;</a>
              </div>
              <p>This checks the 0th output of the transaction, and makes sure that it is paid to an
address within the targetrange that we&#39;ve specified.
TODO: remove this check by looping over vouts</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="keyword">if</span> (transactionJson.vout.length &lt; <span class="number">1</span>) {
          cb(<span class="string">'there must be at least one vout (there may be another to get change)'</span>);
          <span class="keyword">return</span>;
        }</pre></div></div>
            
        </li>
        
        
        <li id="section-56">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-56">&#182;</a>
              </div>
              <p>TODO: other vouts work too, maybe even add them up?
We expect double the amount, because we&#39;re getting back the amount we paid</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        assert.equal(Math.round(transactionJson.vout[<span class="number">0</span>][<span class="string">'value'</span>] * SATOSHIS), AMOUNT * <span class="number">2</span>);

        <span class="keyword">var</span> destinationAddress = transactionJson.vout[<span class="number">0</span>].scriptPubKey.addresses[<span class="number">0</span>];</pre></div></div>
            
        </li>
        
        
        <li id="section-57">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-57">&#182;</a>
              </div>
              <p>This is the txid that the payer guessed</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="keyword">var</span> previousTxid = transactionJson.vin[<span class="number">0</span>].txid;
        <span class="keyword">var</span> previousTxidBi = <span class="keyword">new</span> BigInteger();
        previousTxidBi.fromString(previousTxid, <span class="number">16</span>);</pre></div></div>
            
        </li>
        
        
        <li id="section-58">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-58">&#182;</a>
              </div>
              <p>validate that toAddress isn&#39;t our own address</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="keyword">if</span> (destinationAddress != address) {
          cb(<span class="string">'wrong destination address: is '</span> + destinationAddress + <span class="string">', should be '</span> + address);
          <span class="keyword">return</span>;
        }</pre></div></div>
            
        </li>
        
        
        <li id="section-59">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-59">&#182;</a>
              </div>
              <p>If there&#39;s no target set up, we can&#39;t be paid</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="keyword">if</span> (!currentTarget) {
          cb(<span class="string">'No target set up'</span>);
          <span class="keyword">return</span>;
        }</pre></div></div>
            
        </li>
        
        
        <li id="section-60">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-60">&#182;</a>
              </div>
              <p>previous txid is lower than this target, no good</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="keyword">if</span> (previousTxidBi.compareTo(currentTarget.start) &lt; <span class="number">0</span>) {
          cb(<span class="string">'txid too low'</span>);
          <span class="keyword">return</span>;
        }</pre></div></div>
            
        </li>
        
        
        <li id="section-61">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-61">&#182;</a>
              </div>
              <p>previous txid is higher than this target, no good</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="keyword">var</span> targetLength = <span class="keyword">new</span> BigInteger();
        targetLength.fromInt(currentTarget.length);
        <span class="keyword">var</span> targetEnd = currentTarget.start.add(targetLength);
        <span class="keyword">if</span> (previousTxidBi.compareTo(targetEnd) &gt;= <span class="number">0</span>) {
          cb(<span class="string">'txid too high'</span>);
          <span class="keyword">return</span>;
        }</pre></div></div>
            
        </li>
        
        
        <li id="section-62">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-62">&#182;</a>
              </div>
              <p>Wrong guess. The voucher was valid but not cashable</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="keyword">var</span> targetOffset = <span class="keyword">new</span> BigInteger();
        targetOffset.fromInt(currentTarget.offset);
        <span class="keyword">if</span> (previousTxidBi.compareTo(currentTarget.start.add(targetOffset)) !== <span class="number">0</span>) {
          cb(<span class="literal">null</span>, <span class="literal">false</span>);</pre></div></div>
            
        </li>
        
        
        <li id="section-63">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-63">&#182;</a>
              </div>
              <p>Destroy the target.  Otherwise the payer could re-guess with a higher probability of
correctness</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          currentTarget = <span class="literal">null</span>;
          <span class="keyword">return</span>;
        }</pre></div></div>
            
        </li>
        
        
        <li id="section-64">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-64">&#182;</a>
              </div>
              <p>The voucher was valid and cashable.  Cash it!  #getmoney</p>
<p>First, submit the setup transaction</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        client.cmd(<span class="string">'sendrawtransaction'</span>, currentTarget.transactionHex, <span class="keyword">function</span>(err, txid) {
          <span class="keyword">if</span>(err) {</pre></div></div>
            
        </li>
        
        
        <li id="section-65">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-65">&#182;</a>
              </div>
              <p>We couldn&#39;t submit the setup transaction?  Yuck.  Bitcoin-Qt closed, maybe?</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>            cb(<span class="string">'Error sending setup transaction: '</span> + currentTarget.transactionHex + <span class="string">' '</span> + err);
            <span class="keyword">return</span>;
          }</pre></div></div>
            
        </li>
        
        
        <li id="section-66">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-66">&#182;</a>
              </div>
              <p>Now that we&#39;ve used this target, get rid of it</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          currentTarget = <span class="literal">null</span>;</pre></div></div>
            
        </li>
        
        
        <li id="section-67">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-67">&#182;</a>
              </div>
              <p>TODO: how do we tell the difference between invalid and uncashable if this call fails?</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          client.cmd(<span class="string">'sendrawtransaction'</span>, transactionHex, <span class="keyword">function</span>(err, txid) {
            <span class="keyword">if</span>(err) {
              cb(<span class="string">'Error sending real transaction: '</span> + err);
            } <span class="keyword">else</span> {
              cb(<span class="literal">null</span>, <span class="literal">true</span>);
            }
          });
        });
      });
    };
  };
};

Object.freeze(exports);</pre></div></div>
            
        </li>
        
    </ul>
  </div>
</body>
</html>
